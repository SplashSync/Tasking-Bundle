<?php

namespace Splash\Tasking\Repository;

use DateInterval;

use Splash\Tasking\Entity\Token  as Token;

use UserBundle\Entity\User      as User;

/**
 * TaskRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class TaskRepository extends \Doctrine\ORM\EntityRepository
{
    
    var $qb;
    
    /**
     *      @abstract    Load New Task To Perform from Db with Filter for Used Tokens 
     * 
     *      @param  int         $ErrorDelay     Delay before we consider a task as faulty
     *      @param  int         $TryDelay       Delay before we retry a task execution
     *      @param  string      $Token          Focus on a Specific Token (When Already Acquired)
     *      @param  bool        $Static         Search fro Static Tasks
     */        
    function getNextTask($Options, $Token = Null, $Static = False)
    {
        //====================================================================//
        // Init Query Builder
        $this->qb   =   $this->createQueryBuilder("task");
        
        //====================================================================//
        // Setup Task Filters
        if ( !$Static ) {
            $this->setupNormalTasksFilter();
        } else {
            $this->setupStaticTasksFilter();
        }
        
        //====================================================================//
        // Setup Token Filters
        $this->setupTokenFilter($Token);
        
        //====================================================================//
        // Set Dates Parameters as TimeStamps
        $NowTimeStamp   =   (new \DateTime())->getTimestamp();        
        
        //====================================================================//
        // Setup Query Token Parameters
        if ($Token) {
            $this->qb->setParameter('TokenName'     , $Token);
        } else {
            $this->qb->setParameter('TokenExpireDate'   , ($NowTimeStamp - Token::SELFRELEASE_DELAY));        
        }

        //====================================================================//
        // Setup Query Time Parameters
        if ($Static) {
            $this->qb->setParameter('Now'       , $NowTimeStamp);
        }
        
        $this->qb
            ->setParameter('MaxTry'             , $Options["try_count"])                        // Max. Failled Executions
            ->setParameter('ErrorDate'          , ($NowTimeStamp - $Options["error_delay"]))    // Delay to consider Task is In Error & Retry
            ->setParameter('MaxDate'            , ($NowTimeStamp - $Options["try_delay"]))      // Delay Before retry an unfinished Task
            ->setMaxResults(1);
        
        return $this->qb->getQuery()->getOneOrNullResult();
    }
    
    /**
     *      @abstract    Load Tasks Summmary Array
     * 
     *      @param  string    $IndexKey1         Your Custom Index Key 1
     *      @param  string    $IndexKey2         Your Custom Index Key 2
     * 
     *      @return array Task Summary Array
     */        
    function getTasksSummary(string $IndexKey1 = Null, string $IndexKey2 = Null)
    {
        //====================================================================//
        // Count User Running Tasks
        //====================================================================//
        $WaitingQb = $this->createQueryBuilder("T")
                ->select('count(T.id)')
                ->where("T.running = 0")
                ->andwhere("T.finished = 0");
        $this->setupIndexKeys($WaitingQb, $IndexKey1, $IndexKey2);

        //====================================================================//
        // Count User Running Tasks
        //====================================================================//
        $RunningQb = $this->createQueryBuilder("T")
            ->select('count(T.id)')
            ->where("T.running = 1");
        $this->setupIndexKeys($RunningQb, $IndexKey1, $IndexKey2);
        
        //====================================================================//
        // Count User Finished Tasks
        //====================================================================//
        $FinishedQb = $this->createQueryBuilder("T")
            ->select('count(T.id)')
            ->where("T.running = 0")
            ->andwhere("T.finished = 1");
        $this->setupIndexKeys($FinishedQb, $IndexKey1, $IndexKey2);

        //====================================================================//
        // Count User Total of Tasks
        //====================================================================//
        $TotalQb = $this->createQueryBuilder("T")
            ->select('count(T.id)');
        $this->setupIndexKeys($TotalQb, $IndexKey1, $IndexKey2);

        //====================================================================//
        // Compte Results Array
        //====================================================================//
        return array (
            "Waiting"   => $WaitingQb->getQuery()->getSingleScalarResult(),
            "Running"   => $RunningQb->getQuery()->getSingleScalarResult(),
            "Finished"  => $FinishedQb->getQuery()->getSingleScalarResult(),
            "Total"     => $TotalQb->getQuery()->getSingleScalarResult()
        );
    }
    
    /**
     *      @abstract    Load User Task Summmary Array
     * 
     *      @param  User    $User         Delay before we consider a task as faulty
     * 
     *      @return array User Task Summary Array
     */        
    function getUserTasks(User $User, $Grouped = True,  $Limit = 25)
    {
        //====================================================================//
        // Search for User Tasks
        //====================================================================//
        return $this->createQueryBuilder("T")
            //====================================================================//
            // Select User Tasks
            ->where("T.user = :User")
            ->andwhere("T.jobIsStatic != 1")
            ->orderBy("T.createdAt", "DESC")
            ->setParameter('User'  , $User)
            ->setMaxResults($Limit)
            ->getQuery()
            ->getResult();
    }
    
    /**
     * @abstract    Load User Task Array, Sorted By Type
     * 
     * @param   string      $Key1           Your Custom Index Key 1
     * @param   string      $Key2           Your Custom Index Key 2
     * @param   array       $OrderBy        List Ordering
     * @param   int         $Limit          Limit Number of Items
     * @param   int         $Offset         Page Offset
     * 
     * @return array User Task Summary Array
     */        
    function getTasksStatus( string $Key1 = Null, string $Key2 = Null, array $OrderBy = [], int $Limit = 10, int $Offset = 0 )
    {
        //====================================================================//
        // Get List of Tasks By Types 
        //====================================================================//
        $StatusQuery    =   $this
                ->createQueryBuilder("T")
                ->select(array('T.name','count(T.name) as Total','T.discriminator as Md5', 'T.settings'))    
                ->groupBy("T.discriminator");
        
        $this
                ->setupIndexKeys($StatusQuery, $Key1, $Key2)
                ->setupOrderBy($StatusQuery, $OrderBy)
                ->setupLimit($StatusQuery, $Limit)
                ->setupOffset($StatusQuery, $Offset);
        
        $Status = $StatusQuery->getQuery()
            ->getArrayResult();
        
        //====================================================================//
        // Add Tasks Counters 
        //====================================================================//
        foreach ($Status as &$TaskStatus) {
            $TaskStatus["Waiting"]  = $this->getWaitingTasksCount(Null,$TaskStatus["Md5"],$Key1,$Key2);
            $TaskStatus["Running"]  = $this->getActiveTasksCount(Null,$TaskStatus["Md5"],$Key1,$Key2);
            $TaskStatus["Finished"] = $TaskStatus["Total"] - $TaskStatus["Waiting"] - $TaskStatus["Running"];
        }
        
        return $Status;
    }    
    
    /**
     *      @abstract    Return Number of Active Tasks
     * 
     *      @param  string      $TokenName  Filter on a specific token Name
     *      @param  string      $Md5        Filter on a specific Discriminator
     *      @param  string      $Key1           Your Custom Index Key 1
     *      @param  string      $Key2           Your Custom Index Key 2
     * 
     *      @return int
     */        
    function getActiveTasksCount(string $TokenName = Null, string $Md5 = Null, string $Key1 = Null, string $Key2 = Null)
    {
        //====================================================================//
        // Count Active/Running Tasks
        //====================================================================//
        $Qb = $this->createQueryBuilder("T")
            ->select('count(T.id)')
            ->where("T.running = 1")
            ->andwhere("T.finished = 0");
        
        //====================================================================//
        // Filter Tasks 
        //====================================================================//
        $this
            ->setupIndexKeys($Qb, $Key1, $Key2)
            ->setupToken($Qb, $TokenName)
            ->setupDiscriminator($Qb, $Md5);
        
        return $Qb->getQuery()->getSingleScalarResult();
    }
    
    /**
     *      @abstract    Return Number of Active Tasks
     * 
     *      @param  string      $TokenName  Filter on a specific token Name
     *      @param  string      $Md5        Filter on a specific Discriminator
     *      @param  string      $Key1           Your Custom Index Key 1
     *      @param  string      $Key2           Your Custom Index Key 2
     * 
     *      @return int
     */        
    function getWaitingTasksCount($TokenName = Null, string $Md5 = Null, string $Key1 = Null, string $Key2 = Null)
    {
        //====================================================================//
        // Count Active/Running Tasks
        //====================================================================//
        $Qb = $this->createQueryBuilder("T")
            ->select('count(T.id)')
            ->where("T.running = 0")
            ->andwhere("T.finished = 0");
        
        //====================================================================//
        // Filter Tasks 
        //====================================================================//
        $this
            ->setupIndexKeys($Qb, $Key1, $Key2)
            ->setupToken($Qb, $TokenName)
            ->setupDiscriminator($Qb, $Md5);
        
        return $Qb->getQuery()->getSingleScalarResult();
    }
    
    /**
     *      @abstract    Delete all Tasks finished for more than given delay 
     * 
     *      @return      int        Count pof Deleted Tasks
     */        
    function Clean($Age)
    {
        //==============================================================================
        // Prepare Max Age DateTime
        $MaxDate = (new \DateTime())->getTimestamp() - $Age;
        
        //==============================================================================
        // Count Old Finished Tasks
        $Count = $this->createQueryBuilder("t")
            ->delete()
            ->where("t.finished = 1")
            ->andwhere("t.finishedAtTimeStamp < :maxage")
            ->andwhere("t.jobIsStatic != 1")
            ->setParameter(":maxage" , $MaxDate )
            ->getQuery()
            ->execute();        
        
        return $Count;        
    }
        
    /**
     *      @abstract    Load Static Task Summmary Array
     * 
     *      @param  User    $User         Delay before we consider a task as faulty
     * 
     *      @return array User Task Summary Array
     */        
    function getStaticTasks()
    {
        //==============================================================================
        // Count Old Finished Tasks
        return $this->createQueryBuilder("t")
            ->where("t.jobIsStatic = 1")
            ->getQuery()
            ->execute();  
    }    
    
//====================================================================//
// *******************************************************************//
//  Low Level Functions
// *******************************************************************//
//====================================================================//    
    
    /**
     *      @abstract    Generate Active Tokens Query DQL 
     * 
     */        
    private function getActiveTokensDQL()
    {    
        return $this->_em->createQueryBuilder()
            ->select('tokens.name')
            ->from('Splash\Tasking\Entity\Token', 'tokens')
            ->where("tokens.locked = 1")                                    // Token is Locked
            ->andwhere("tokens.lockedAtTimeStamp > :TokenExpireDate")       // Token Started before Error Date
            ->getDQL();
    }
    
    /**
     *      @abstract    Select Tasks That Have Inactive Tokens or Given Token
     */        
    private function setupTokenFilter($Token = False)
    {    
        //====================================================================//
        // Filter Task with Given Token
        if ($Token) {
            $this->qb->andwhere('task.jobToken = :TokenName');            
        } else {
            $this->qb->andwhere($this->qb->expr()->notIn('task.jobToken', $this->getActiveTokensDQL()));        
        }
        
        return $this;
    }   
    
    /**
     *      @abstract    Select Tasks That Shall be Performed
     */        
    private function setupNormalTasksFilter()
    {    
        $this->qb
            //====================================================================//
            // Select Tasks That Shall be Performed
            ->add('where', $this->qb->expr()->orX(
                // Task Is Not Running
                'task.try = 0 AND task.running = 0',
                // If Task has Already been tried, but failled
                "task.try > 0 AND task.try < :MaxTry AND task.running = 0 AND task.startedAtTimeStamp <=  :MaxDate",
                // If Task Timeout Exeeded
                "task.try < :MaxTry AND task.running = 1 AND task.startedAtTimeStamp <= :ErrorDate"
             ))   
            //====================================================================//
            // Select Tasks That Are Not Static
            ->andwhere('task.finished != 1' )                      
            //====================================================================//
            // Select Tasks That Are Not Static
            ->andwhere('task.jobIsStatic != 1' )                      
        ;
        
        return $this;
    }    
    
    /**
     *      @abstract    Select Tasks That Shall be Performed
     */        
    private function setupStaticTasksFilter()
    {    
        $this->qb
            //====================================================================//
            // Select Tasks That Shall be Performed
            ->add('where', $this->qb->expr()->orX(
                // Task Is Not Running
                'task.try = 0 AND task.running = 0 AND task.finished = 0',
                // If Task has Already been tried, but failled
                "task.try > 0 AND task.try < :MaxTry AND task.running = 0 AND task.finished = 0 AND task.startedAtTimeStamp <  :MaxDate",
                // If Task Timeout Exeeded
                "task.try < :MaxTry AND task.running = 1 AND task.startedAtTimeStamp < :ErrorDate",
                // If Task Need Restart
                "task.running = 0 AND task.finished = 1 AND task.plannedAtTimeStamp <  :Now"                    
             ))    
            //====================================================================//
            // Select Tasks That Are Not Static
            ->andwhere('task.jobIsStatic != 0' )                   
        ;
        
        return $this;
    }    

    /**
     * @abstract    Setup Index Keys Filter on a QueryBuilder
     *  
     * @param   builder     $QueryBuilder       Target QueryBuilder
     * @param   string      $IndexKey1          Your Custom Index Key 1
     * @param   string      $IndexKey2          Your Custom Index Key 2
     */        
    private function setupIndexKeys(&$QueryBuilder, string $IndexKey1 = Null , string $IndexKey2 = Null) {
        if ( !empty($IndexKey1) ) {
            $QueryBuilder->andwhere("T.jobIndexKey1 = '" . $IndexKey1 . "'" );
        }
        if ( !empty($IndexKey2) ) {
            $QueryBuilder->andwhere("T.jobIndexKey2 = '" . $IndexKey2 . "'" );
        }
        
        return $this;
    }    
    
    /**
     * @abstract    Setup Order By Filter on a QueryBuilder
     *  
     * @param   builder     $QueryBuilder       Target QueryBuilder
     * @param   array       $OrderBy            OrderBy Array
     */        
    private function setupOrderBy(&$QueryBuilder, array $OrderBy = [] ) {
        if ( !empty($OrderBy) ) {
            $Count = 0;
            foreach ($OrderBy as $Key => $Dir ) {
                if (!$Count) {
                    $QueryBuilder->orderBy($Key,$Dir);
                } else {
                    $QueryBuilder->andOrderBy($Key,$Dir);
                }
                $Count++;
            }
        } 
        
        return $this;
    }
    
    /**
     * @abstract    Setup Limit Filter on a QueryBuilder
     *  
     * @param   builder     $QueryBuilder       Target QueryBuilder
     * @param   int         $Limit              Result Limit
     */        
    private function setupLimit(&$QueryBuilder, int $Limit = Null ) {
        if ( !empty($Limit) ) {
            $QueryBuilder->setMaxResults($Limit);
        }
        
        return $this;
    }
    
    /**
     * @abstract    Setup Offset Filter on a QueryBuilder
     *  
     * @param   builder     $QueryBuilder       Target QueryBuilder
     * @param   int         $Offset             Pagination Offset
     */        
    private function setupOffset(&$QueryBuilder, int $Offset = Null ) {
        if ( !empty($Offset) ) {
            $QueryBuilder->setFirstResult($Offset);
        }
        
        return $this;
    }
    
    /**
     * @abstract    Setup Token Filter on a QueryBuilder
     *  
     * @param   builder     $QueryBuilder       Target QueryBuilder
     * @param  string       $TokenName          Filter on a specific token Name
     */        
    private function setupToken(&$QueryBuilder, string $TokenName = Null ) {
        
        if ( !empty($TokenName) ) {
            $QueryBuilder
                ->andwhere("T.jobToken = :Token")
                ->setParameter('Token'  , $TokenName)
            ;
        }
        
        return $this;
    }
    
    /**
     * @abstract    Setup Token Filter on a QueryBuilder
     *  
     * @param   builder     $QueryBuilder       Target QueryBuilder
     * @param   string      $Md5                Filter on a specific Discriminator
     */        
    private function setupDiscriminator(&$QueryBuilder, string $Md5 = Null ) {
        
        if ( !empty($Md5) ) {
            $QueryBuilder
                ->andwhere("T.discriminator = :Md5")
                ->setParameter('Md5'  , $Md5)
            ;
        }
        
        return $this;
    }
    
}
