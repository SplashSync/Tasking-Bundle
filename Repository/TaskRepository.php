<?php

namespace Splash\Tasking\Repository;

use DateInterval;

use Splash\Tasking\Entity\Token  as Token;

use UserBundle\Entity\User      as User;

/**
 * TaskRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class TaskRepository extends \Doctrine\ORM\EntityRepository
{
    
    var $qb;
    
    /**
     *      @abstract    Load New Task To Perform from Db with Filter for Used Tokens 
     * 
     *      @param  int         $ErrorDelay     Delay before we consider a task as faulty
     *      @param  int         $TryDelay       Delay before we retry a task execution
     *      @param  string      $Token          Focus on a Specific Token (When Already Acquired)
     *      @param  bool        $Static         Search fro Static Tasks
     */        
    function getNextTask($ErrorDelay, $TryDelay, $Token = Null, $Static = False)
    {
        //====================================================================//
        // Init Query Builder
        $this->qb   =   $this->createQueryBuilder("task");
        
        //====================================================================//
        // Setup Task Filters
        if ( !$Static ) {
            $this->setupNormalTasksFilter();
        } else {
            $this->setupStaticTasksFilter();
        }
        
        //====================================================================//
        // Setup Token Filters
        $this->setupTokenFilter($Token);
        
        //====================================================================//
        // Set Dates Parameters as TimeStamps
        $NowTimeStamp   =   (new \DateTime())->getTimestamp();        
        
        //====================================================================//
        // Setup Query Token Parameters
        if ($Token) {
            $this->qb->setParameter('TokenName'     , $Token);
        } else {
            $this->qb->setParameter('TokenExpireDate'   , ($NowTimeStamp - Token::SELFRELEASE_DELAY));        
        }

        //====================================================================//
        // Setup Query Time Parameters
        if ($Static) {
            $this->qb->setParameter('Now'       , $NowTimeStamp);
        }
        
        $this->qb
            ->setParameter('ErrorDate'         , ($NowTimeStamp - $ErrorDelay))
            ->setParameter('MaxDate'           , ($NowTimeStamp - $TryDelay))
            ->setMaxResults(1);
        
        
//dump(   $this->_em->createQueryBuilder()
//            ->select('tokens.name')
//            ->from('Splash\Tasking\Entity\Token', 'tokens')
//            ->where("tokens.locked = 1")                                    // Token is Locked
//            ->andwhere("tokens.lockedAtTimeStamp > :TokenExpireDate")       // Token Started before Error Date
//            ->setParameter('TokenExpireDate'   , ($NowTimeStamp - Token::SELFRELEASE_DELAY))
//            ->getQuery()->getResult()
//);        
        
        //====================================================================//
        // Execute Query
//        dump($this->qb->getQuery()->getDQL());
//        dump($this->qb->getQuery()->getParameters());
        
        return $this->qb->getQuery()->getOneOrNullResult();
    }
    
    /**
     *      @abstract    Load User Task Summmary Array
     * 
     *      @param  User    $User         Delay before we consider a task as faulty
     * 
     *      @return array User Task Summary Array
     */        
    function getUserTasksSummary(User $User)
    {
        //====================================================================//
        // Count User Running Tasks
        //====================================================================//
        $Waiting = $this->createQueryBuilder("T")
            ->select('count(T.id)')
            ->where("T.user = :User")
            ->andwhere("T.running = 0")
            ->andwhere("T.finished = 0")
            ->setParameter('User'  , $User)
            ->getQuery()->getSingleScalarResult();
        //====================================================================//
        // Count User Running Tasks
        //====================================================================//
        $Running = $this->createQueryBuilder("T")
            ->select('count(T.id)')
            ->where("T.user = :User")
            ->andwhere("T.running = 1")
            ->setParameter('User'  , $User)
            ->getQuery()->getSingleScalarResult();
        //====================================================================//
        // Count User Finished Tasks
        //====================================================================//
        $Finished = $this->createQueryBuilder("T")
            ->select('count(T.id)')
            ->where("T.user = :User")
            ->andwhere("T.finished = 1")
            ->setParameter('User'  , $User)
            ->getQuery()->getSingleScalarResult();

        
        return array (
            "Waiting"   => $Waiting,
            "Running"   => $Running,
            "Finished"  => $Finished
        );
    }
    
    /**
     *      @abstract    Load User Task Summmary Array
     * 
     *      @param  User    $User         Delay before we consider a task as faulty
     * 
     *      @return array User Task Summary Array
     */        
    function getUserTasks(User $User, $Grouped = True,  $Limit = 25)
    {
        //====================================================================//
        // Search for User Tasks
        //====================================================================//
        return $this->createQueryBuilder("T")
            //====================================================================//
            // Select User Tasks
            ->where("T.user = :User")
            ->andwhere("T.jobIsStatic != 1")
            ->orderBy("T.createdAt", "DESC")
            ->setParameter('User'  , $User)
            ->setMaxResults($Limit)
            ->getQuery()
            ->getResult();
    }
    
    /**
     *      @abstract    Load User Task Array, Sorted By Type
     * 
     *      @param  User    $User         Delay before we consider a task as faulty
     * 
     *      @return array User Task Summary Array
     */        
    function getUserSortedTasks(User $User)
    {
        $Summary = array();
        
        //====================================================================//
        // Waiting Tasks Types 
        //====================================================================//
        $Waiting    =    $this->createQueryBuilder("T")
            ->select(array('T.name','count(T.name)','T.settings'))    
            ->where("T.user = :User")
            ->andwhere("T.running = 0")
            ->andwhere("T.finished = 0")
            ->setParameter('User'  , $User)
            ->groupBy("T.name")
//            ->addGroupBy("T.settings")
            ->getQuery()
            ->getArrayResult();
        

        foreach ( $Waiting as $TaskType ) {
            if (!array_key_exists($TaskType["name"],$Summary)){
                $Summary[$TaskType["name"]] = array(
                    "Name"      => $TaskType["name"], 
                    "Waiting"   => 0, 
                    "Running"   => 0, 
                    "Finished"  => 0, 
                    "Total"     => 0, 
                    "Settings"  => $TaskType['settings']);
            }
            $Summary[$TaskType["name"]]["Waiting"]      =   (int) $TaskType['1']; 
            $Summary[$TaskType["name"]]["Total"]        +=  $TaskType['1']; 
            
        }
        
        //====================================================================//
        // Running Tasks Types 
        //====================================================================//
        $Running    =    $this->createQueryBuilder("T")
            ->select(array('T.name','count(T.name)','T.settings'))   
            ->where("T.user = :User")
            ->andwhere("T.running = 1")
            ->andwhere("T.finished = 0")
            ->setParameter('User'  , $User)
            ->groupBy("T.name")
//            ->addGroupBy("T.settings")
            ->getQuery()
            ->getArrayResult();
        foreach ( $Running as $TaskType ) {
            if (!array_key_exists($TaskType["name"],$Summary)){
                $Summary[$TaskType["name"]] = array(
                    "Name"      => $TaskType["name"], 
                    "Waiting"   => 0, 
                    "Running"   => 0, 
                    "Finished"  => 0, 
                    "Total"     => 0, 
                    "Settings"  => $TaskType['settings']);
            }
            $Summary[$TaskType["name"]]["Running"]      =   (int) $TaskType['1']; 
            $Summary[$TaskType["name"]]["Total"]        +=  $TaskType['1']; 
        }
        
        //====================================================================//
        // Finished Tasks Types 
        //====================================================================//
        $Finished    =    $this->createQueryBuilder("T")
            ->select(array('T.name','count(T.name)','T.settings'))    
            ->where("T.user = :User")
            ->andwhere("T.running = 0")
            ->andwhere("T.finished = 1")
            ->setParameter('User'  , $User)
            ->groupBy("T.name")
//            ->addGroupBy("T.settings")
            ->getQuery()
            ->getArrayResult();
        foreach ( $Finished as $TaskType ) {
            if (!array_key_exists($TaskType["name"],$Summary)){
                $Summary[$TaskType["name"]] = array(
                    "Name"      => $TaskType["name"], 
                    "Waiting"   => 0, 
                    "Running"   => 0, 
                    "Finished"  => 0, 
                    "Total"     => 0, 
                    "Settings"  => $TaskType['settings']);
            }
            $Summary[$TaskType["name"]]["Finished"]     =   (int) $TaskType['1']; 
            $Summary[$TaskType["name"]]["Total"]        +=  $TaskType['1']; 
        }

        return $Summary;
    }    
    
    /**
     *      @abstract    Return Number of Active Tasks
     * 
     *      @param  string      $TokenName  Filter on a specific token Name
     * 
     *      @return int
     */        
    function getActiveTasksCount($TokenName = Null)
    {
        //====================================================================//
        // Count Active/Running Tasks
        //====================================================================//
        $Qb = $this->createQueryBuilder("T")
            ->select('count(T.id)')
            ->where("T.running = 1")
            ->andwhere("T.finished = 0");
        
        //====================================================================//
        // Filter Tasks
        //====================================================================//
        if ($TokenName) {
            $Qb
                ->andwhere("T.jobToken = :Token")
                ->setParameter('Token'  , $TokenName)
            ;
        }
        
        return $Qb->getQuery()->getSingleScalarResult();
    }
    
    /**
     *      @abstract    Return Number of Active Tasks
     * 
     *      @param  string      $TokenName  Filter on a specific token Name
     * 
     *      @return int
     */        
    function getWaitingTasksCount($TokenName = Null)
    {
        //====================================================================//
        // Count Active/Running Tasks
        //====================================================================//
        $Qb = $this->createQueryBuilder("T")
            ->select('count(T.id)')
            ->where("T.running = 0")
            ->andwhere("T.finished = 0");
        
        //====================================================================//
        // Filter Tasks
        //====================================================================//
        if ($TokenName) {
            $Qb
                ->andwhere("T.jobToken = :Token")
                ->setParameter('Token'  , $TokenName)
            ;
        }
        
        return $Qb->getQuery()->getSingleScalarResult();
    }
    
    /**
     *      @abstract    Delete all Tasks finished for more than given delay 
     * 
     *      @return      int        Count pof Deleted Tasks
     */        
    function Clean($Age)
    {
        //==============================================================================
        // Prepare Max Age DateTime
        $MaxDate = (new \DateTime())->getTimestamp() - $Age;
        
        //==============================================================================
        // Count Old Finished Tasks
        $Count = $this->createQueryBuilder("t")
            ->delete()
            ->where("t.finished = 1")
            ->andwhere("t.finishedAtTimeStamp < :maxage")
            ->andwhere("t.jobIsStatic != 1")
            ->setParameter(":maxage" , $MaxDate )
            ->getQuery()
            ->execute();        
        
        return $Count;        
    }
        
    /**
     *      @abstract    Load Static Task Summmary Array
     * 
     *      @param  User    $User         Delay before we consider a task as faulty
     * 
     *      @return array User Task Summary Array
     */        
    function getStaticTasks()
    {
        //==============================================================================
        // Count Old Finished Tasks
        return $this->createQueryBuilder("t")
            ->where("t.jobIsStatic = 1")
            ->getQuery()
            ->execute();  
    }    
    
//====================================================================//
// *******************************************************************//
//  Low Level Functions
// *******************************************************************//
//====================================================================//    
    
    /**
     *      @abstract    Generate Active Tokens Query DQL 
     * 
     */        
    private function getActiveTokensDQL()
    {    
        return $this->_em->createQueryBuilder()
            ->select('tokens.name')
            ->from('Splash\Tasking\Entity\Token', 'tokens')
            ->where("tokens.locked = 1")                                    // Token is Locked
            ->andwhere("tokens.lockedAtTimeStamp > :TokenExpireDate")       // Token Started before Error Date
            ->getDQL();
    }
    
    /**
     *      @abstract    Select Tasks That Have Inactive Tokens or Given Token
     */        
    private function setupTokenFilter($Token = False)
    {    
        //====================================================================//
        // Filter Task with Given Token
        if ($Token) {
            $this->qb->andwhere('task.jobToken = :TokenName');            
        } else {
            $this->qb->andwhere($this->qb->expr()->notIn('task.jobToken', $this->getActiveTokensDQL()));        
        }
        
        return $this;
    }   
    
    /**
     *      @abstract    Select Tasks That Shall be Performed
     */        
    private function setupNormalTasksFilter()
    {    
        $this->qb
            //====================================================================//
            // Select Tasks That Shall be Performed
            ->add('where', $this->qb->expr()->orX(
                // Task Is Not Running
                'task.try = 0 AND task.running = 0',
                // If Task has Already been tried, but failled
                "task.try > 0 AND task.running = 0 AND task.startedAtTimeStamp <=  :MaxDate",
                // If Task Timeout Exeeded
                "task.running = 1 AND task.startedAtTimeStamp <= :ErrorDate"
             ))   
            //====================================================================//
            // Select Tasks That Are Not Static
            ->andwhere('task.finished != 1' )                      
            //====================================================================//
            // Select Tasks That Are Not Static
            ->andwhere('task.jobIsStatic != 1' )                      
        ;
        
        return $this;
    }    
    
    /**
     *      @abstract    Select Tasks That Shall be Performed
     */        
    private function setupStaticTasksFilter()
    {    
        $this->qb
            //====================================================================//
            // Select Tasks That Shall be Performed
            ->add('where', $this->qb->expr()->orX(
                // Task Is Not Running
                'task.try = 0 AND task.running = 0 AND task.finished = 0',
                // If Task has Already been tried, but failled
                "task.try > 0 AND task.running = 0 AND task.finished = 0 AND task.startedAtTimeStamp <  :MaxDate",
                // If Task Timeout Exeeded
                "task.running = 1 AND task.startedAtTimeStamp < :ErrorDate",
                // If Task Need Restart
                "task.running = 0 AND task.finished = 1 AND task.plannedAt <  :Now"                    
             ))    
            //====================================================================//
            // Select Tasks That Are Not Static
            ->andwhere('task.jobIsStatic != 0' )                   
        ;
        
        return $this;
    }    
        
}
