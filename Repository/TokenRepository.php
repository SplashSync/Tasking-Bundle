<?php

namespace Splash\Tasking\Repository;

use Doctrine\DBAL\LockMode;
//use Doctrine\ORM\PessimisticLockException;
use Doctrine\ORM\OptimisticLockException;

use Doctrine\ORM\EntityRepository;

use Splash\Tasking\Entity\Token;

/**
 * TokenRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class TokenRepository extends EntityRepository
{
    
    const MODE_NORMAL           = "Normal";         // Token Acquire Mode => Normal => No coucurency management
    const MODE_OPTIMISTIC       = "Optimist";       // Token Acquire Mode => Optimistic Locking

    var $Mode = self::MODE_OPTIMISTIC;
        
    /**
     *      @abstract    Verify this token is free and Acquire it
     * 
     *      @param      string   $TokenName  Token Name to Acquire
     * 
     *      @returbn     mixed   False is Token not found or already Locked, $Token Entity if Lock Acquired 
     */     
    function Acquire($TokenName)
    {
        switch ($this->Mode) {
            case self::MODE_NORMAL:
                return $this->AcquireNormal($TokenName);
            case self::MODE_OPTIMISTIC:
                return $this->AcquireOptimistic($TokenName);
        }
        
        return False;        
    }
    
    /**
     *      @abstract    Release this token
     * 
     *      @param      string   $TokenName  Token Name to Acquire
     * 
     *      @return     mixed   False is Token could not be Released 
     */     
    function Release($TokenName)
    {
        switch ($this->Mode) {
            case self::MODE_NORMAL:
                return $this->ReleaseNormal($TokenName);
            case self::MODE_OPTIMISTIC:
                return $this->ReleaseOptimistic($TokenName);
        }
        
        return False; 
    }
    
    /**
     *      @abstract    Verify this token is free and Acquire it
     *                      No Locking Mode
     * 
     *      @param      string   $TokenName  Token Name to Acquire
     * 
     *      @returbn     mixed   False is Token not found or already Locked, $Token Entity if Lock Acquired 
     */     
    function AcquireNormal($TokenName)
    {
        //==============================================================================
        // Ckeck If this token Exists Token Key Name
        $Token = $this->findOneByName( $TokenName );
            
        //==============================================================================
        // Create token if necessary
        if ( !$Token ) {
            $Token = new Token($TokenName);
            $this->_em->persist($Token);
            $this->_em->flush();
        }
        //==============================================================================
        // Token is already locked => Exit
        if ( $Token->isLocked() ) {
            return False;        
        }
        //====================================================================//
        // Set Token As Locked
        $Token->Acquire();
        //====================================================================//
        // Save Changes
        $this->_em->flush();
        
        return $Token;
    }
    
    /**
     *      @abstract    Release this token
     *                      No Locking Mode
     * 
     *      @param      string   $TokenName  Token Name to Acquire
     * 
     *      @return     mixed   False is Token could not be Released 
     */     
    function ReleaseNormal($TokenName)
    {

        //==============================================================================
        // Ckeck If this token Exists Token Key Name
        $Token = $this->findOneByName( $TokenName );
        //==============================================================================
        //If Token Doesn't Exists
        if ( !$Token ) {
            return True;
        }
        //====================================================================//
        // Set Token As Unlocked
        $Token->Release();
        //====================================================================//
        // Save Changes
        $this->_em->flush();
        
        return True;
        
    }
    
    /**
     *      @abstract    Verify this token is free and Acquire it
     *                      Optimistic Locking Mode
     * 
     *      @param      string   $TokenName  Token Name to Acquire
     * 
     *      @returbn     mixed   False is Token not found or already Locked, $Token Entity if Lock Acquired 
     */     
    function AcquireOptimistic($TokenName)
    {
        //==============================================================================
        // Ckeck If this token Exists Token Key Name
        $Token = $this->findOneByName( $TokenName );
        //==============================================================================
        // Create token if necessary
        if ( !$Token ) {
            $Token = new Token($TokenName);
            $this->_em->persist($Token);
            $this->_em->flush();
        }
        $this->_em->refresh($Token);
        //==============================================================================
        // Token is already locked => Exit
        if ( $Token->isLocked() ) {
            return False;        
        }
               
        //==============================================================================
        // Lock token in database
        //==============================================================================
        try {        
//            throw new OptimisticLockException("Simulated Collistion" , $Token);
            //====================================================================//
            // Lock this Entity on EntityManager
            $this->_em->lock($Token, LockMode::OPTIMISTIC, $Token->getVersion() );
            //====================================================================//
            // Set Token As Locked
            $Token->Acquire();
            //====================================================================//
            // Save Changes
            $this->_em->flush();
            return $Token;
            
        } catch (OptimisticLockException $e) {
            echo "Token Rejected (Optimistic) => " . $e->getMessage() . PHP_EOL;
            die;
        }
        
        return False;        
        
    }
    
    /**
     *      @abstract    Release this token
     *                      Optimistic Locking Mode
     * 
     *      @param      string   $TokenName  Token Name to Acquire
     * 
     *      @return     mixed   False is Token could not be Released 
     */     
    function ReleaseOptimistic($TokenName)
    {
        //==============================================================================
        // Ckeck If this token Exists Token Key Name
        $Token = $this->findOneByName( $TokenName );
        //==============================================================================
        //If Token Doesn't Exists
        if ( !$Token ) {
            return True;
        }
        //==============================================================================
        // Token is already unlocked => Exit
        if ( !$Token->isLocked() ) {
            return False;        
        }
        
        while (1) {
            //==============================================================================
            // UnLock token in database
            //==============================================================================
            try {        

                //====================================================================//
                // Lock this Entity on EntityManager
                $this->_em->lock($Token, LockMode::OPTIMISTIC, $Token->getVersion() );
                //====================================================================//
                // Set Token As Unlocked
                $Token->Release();
                //====================================================================//
                // Save Changes
                $this->_em->flush();
                return True;

            } catch (\Doctrine\ORM\OptimisticLockException $e) {
                echo "Token Not Released (Optimistic) => " . $e->getMessage() . PHP_EOL;
                usleep(1E5);
                continue;        
            }
        
        }
        
        return False;        
    }
    
    /**
     *      @abstract    Initialize a Specific Token before Task Creation  
     * 
     *      @param       string     $TokenKey       Token Name
     * 
     */    
    public function Validate($TokenKey) {
        
        //==============================================================================
        // Ckeck If Token Exists
        $Token = $this->findOneByName( $TokenKey );
        
        //==============================================================================
        // Create token if necessary
        if ( !$Token ) {
            $Token = new Token($TokenKey);
            $this->_em->persist($Token);
            $this->_em->flush();
        }        
        return !empty($Token);
    }    
    
    /**
     *      @abstract    Delete a Token 
     * 
     *      @param  string   $TokenName  Token Name to Acquire
     * 
     *      @return      bool
     */        
    function Delete($TokenName)
    {

        //==============================================================================
        // Ckeck If this token Exists Token Key Name
        $Token = $this->findOneByName( $TokenName );
        //==============================================================================
        // Create token if necessary
        if ( !$Token ) {
            return True;
        }
        //====================================================================//
        // Delete this Entity on EntityManager
        $this->_em->remove($Token);
        //====================================================================//
        // Save Changes
        $this->_em->flush();       
        
        return True;        
    }
    
    /**
     *      @abstract    Delete all Token Unused for more than given delay 
     *  
     *      @return      int        Count pof Deleted Tasks
     */        
    function Clean($Age = Token::DELETE_DELAY)
    {
        //==============================================================================
        // Prepare Max Age DateTime
        $MaxDate = new \DateTime("-" . $Age . "Hours");
        //==============================================================================
        // Count Old Finished Tasks
        $Count = $this->createQueryBuilder("t")
            ->delete()
            ->where("t.locked != 1")
            ->andwhere("t.lockedAt < :maxage OR t.lockedAt IS NULL")
//            ->where("t.lockedAt < :maxage OR t.lockedAt IS NULL")
            ->setParameter(":maxage" , $MaxDate )
            ->getQuery()
            ->execute();        
        
        return $Count;        
    }
        
}
